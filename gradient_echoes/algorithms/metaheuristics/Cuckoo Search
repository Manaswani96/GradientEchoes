import numpy as np
def levy_flight(n, beta=1.5):
    sigma = (np.math.gamma(1+beta) * np.sin(np.pi*beta/2) / (np.math.gamma((1+beta)/2) * beta * 2**((beta-1)/2)))**(1/beta)
    u = np.random.normal(0, sigma, n)
    v = np.random.normal(0, 1, n)
    return u / (np.abs(v)**(1/beta))
def cuckoo_search(f, bounds, n_nests=25, max_iter=100, pa=0.25, alpha=0.01):
    dim = len(bounds)
    nests = np.random.uniform([b[0] for b in bounds], [b[1] for b in bounds], (n_nests, dim))
    fitness = np.array([f(x) for x in nests])
    best_idx = np.argmin(fitness)
    best = nests[best_idx].copy()
    for _ in range(max_iter):
        # Generate new solutions via LÃ©vy flights
        new_nests = nests + alpha * levy_flight((n_nests, dim))
        new_nests = np.clip(new_nests, [b[0] for b in bounds], [b[1] for b in bounds])
        new_fitness = np.array([f(x) for x in new_nests])
        # Replace worse nests
        replace = np.random.rand(n_nests) < pa
        nests[replace] = new_nests[replace]
        fitness[replace] = new_fitness[replace]
        if np.min(new_fitness) < fitness[best_idx]:
            best_idx = np.argmin(new_fitness)
            best = new_nests[best_idx].copy()
    return best, f(best)
