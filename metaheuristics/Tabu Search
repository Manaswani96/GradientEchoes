import numpy as np
from collections import deque

def tabu_search(f, x0, neighborhood_size=10, tabu_size=5, max_iter=100):
    x = x0.copy()
    fx = f(x)
    best_x, best_fx = x.copy(), fx
    tabu = deque(maxlen=tabu_size)  # Recent flips
    
    for _ in range(max_iter):
        neighbors = []
        for i in range(len(x)):
            if i not in tabu:
                neighbor = x.copy()
                neighbor[i] = 1 - neighbor[i]  # Flip
                neighbors.append((neighbor, i))
        if not neighbors:
            break  # All tabu, reset or stop
        
        scores = [(f(n), idx) for n, idx in neighbors]
        best_neighbor, best_idx = min(scores, key=lambda s: s[0])[1], scores[0][1]  # Min score
        x, fx = neighbors[best_neighbor][0], scores[best_neighbor][0]
        tabu.append(best_idx)
        
        if fx < best_fx:
            best_x, best_fx = x.copy(), fx
    
    return best_x, best_fx

# Example: Minimize conflicts in graph coloring or use your fitness funcs.
