from qiskit import QuantumCircuit, Aer
from qiskit.algorithms.optimizers import SPSA
from qiskit.quantum_info import SparsePauliOp
from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.primitives import Estimator
import numpy as np

# Variational Quantum Eigensolver for a 2-qubit Heisenberg Hamiltonian
def vqe_heisenberg():
    # Define 2-qubit Heisenberg Hamiltonian: H = J (X1X2 + Y1Y2 + Z1Z2)
    J = 1.0
    hamiltonian = SparsePauliOp.from_list([
        ("XX", J),
        ("YY", J),
        ("ZZ", J)
    ])
    
    # Define a parameterized ansatz circuit
    def ansatz(params):
        qc = QuantumCircuit(2)
        # Apply parameterized rotations and entangling gate
        qc.ry(params[0], 0)
        qc.ry(params[1], 1)
        qc.cx(0, 1)
        qc.ry(params[2], 0)
        qc.ry(params[3], 1)
        return qc
    
    # Number of parameters in ansatz
    num_params = 4
    initial_params = np.random.random(num_params) * 0.1
    
    # Set up VQE
    estimator = Estimator()
    optimizer = SPSA(maxiter=100)
    vqe = VQE(
        estimator=estimator,
        ansatz=ansatz,
        optimizer=optimizer,
        initial_point=initial_params
    )
    
    # Run VQE to find ground state energy
    result = vqe.compute_minimum_eigenvalue(operator=hamiltonian)
    
    return result

# Run the VQE
result = vqe_heisenberg()

# Print results
print("VQE Results for 2-qubit Heisenberg Hamiltonian:")
print(f"Estimated ground state energy: {result.eigenvalue.real:.4f}")
print(f"Optimal parameters: {result.optimal_parameters}")
print(f"Number of optimizer evaluations: {result.optimizer_evals}")
